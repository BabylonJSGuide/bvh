<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>hitTest</title>

    <script src= "../babylon.max.js"></script>
    <script src= "babylon.glTFFileLoader.js"></script>
	<script src= "morton.js"></script>
    <script src= "bvhByNode.js"></script>
    <script src= "radix.js"></script>
	
	
    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <script>
var arrayToSplit = [];
var switchArray = [];
switchArray[0] = new Set();
switchArray[1] = new Set();
switcher = 0;

if (BABYLON.Engine.isSupported()) {
    var canvas = document.getElementById("renderCanvas");
    var engine = new BABYLON.Engine(canvas, true);


var createScene = function () {

    // This creates a basic Babylon Scene object (non-mesh)
    var scene = new BABYLON.Scene(engine);

    var camera = new BABYLON.ArcRotateCamera("Camera", - Math.PI / 2, Math.PI / 2.2, 5, BABYLON.Vector3.Zero(), scene);

	camera.attachControl(canvas, true);

    // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
    var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 1, 0), scene);

    // Default intensity is 1. Let's dim the light a small amount
	light.intensity = 0.7;

	BABYLON.SceneLoader.ImportMesh("", "https://www.babylonjs.com/Assets/DamagedHelmet/glTF/", "DamagedHelmet.gltf", scene, function (meshes) {          
        let box = meshes[1];
        
    

    let data = codeMapFromMesh(box);
    codes32 = new Uint32Array(data.codes.length);
    codes32.set(data.codes);
    
    var tree = new bvhNode(0, codes32.length - 1, 30, 0, 0);

    arrayToSplit = [tree];
    
    while (arrayToSplit.length > 0) {
        var node = arrayToSplit.pop();
        splitNode(node, codes32);
    }
    console.log("len", codes32.length);
    console.log("base", switchArray[0]);

    switchArray[0].forEach(function(entry) {
        if (switchArray[0].has(entry.sibling)) {
            switchArray[0].delete(entry.sibling);
        }
    });
    console.log("base2", switchArray[0]);


    //************************lowest cluster levels****************
    switchArray[switcher].forEach((entry) => {
        switchArray[switcher].delete(entry);
        let cluster = clusterFromLeaf(entry, data)
        entry.cluster = combineClusters(cluster, cluster.length / 2);
//        if (entry.end === 7348) {
  //          console.log("sib", entry.sibling);
    //    }
        //console.log("entry", entry.cluster);
        if (entry.sibling.left === null && entry.sibling.right === null) {
            let siblingCluster = clusterFromLeaf(entry.sibling, data);
            entry.sibling.cluster = combineClusters(siblingCluster, siblingCluster.length / 2);
            //console.log("union", unionClusters(entry.cluster, entry.sibling.cluster));
            entry.parent.cluster = combineClusters(unionClusters(entry.cluster, entry.sibling.cluster), (entry.cluster.length + entry.sibling.cluster) / 2);
            //console.log("base", entry.start, entry.end, "------", entry.cluster.minX, entry.sibling.cluster.minX, entry.parent.cluster.minX);
            if (!switchArray[(switcher + 1) % 2].has(entry.parent.sibling)) {
                    switchArray[(switcher + 1) % 2].add(entry.parent);
                }
        }
        else {
            switchArray[(switcher + 1) % 2].add(entry);
        }
        
    });

        
    switchArray[switcher].clear();
    switcher++;
    switcher %= 2;
    
    //level++;
N = 0; 
    let atRoot = false;
    let treeCluster = [];
    while (!atRoot && N < 60) {
        switchArray[switcher].forEach((entry) => {
            if (entry.start === 0 && entry.end === codes32.length - 1) {
                treeCluster = combineClusters(entry.cluster, 1);
                atRoot = true;
            }
            switchArray[switcher].delete(entry);
            if (entry.sibling && entry.sibling.cluster !== null) {
                entry.parent.cluster = combineClusters(unionClusters(entry.cluster, entry.sibling.cluster), (entry.cluster.length + entry.sibling.cluster.length) / 2);
                if (!switchArray[(switcher + 1) % 2].has(entry.parent.sibling)) {
                    switchArray[(switcher + 1) % 2].add(entry.parent);
                }
            }
            else {
                switchArray[(switcher + 1) % 2].add(entry);
            }
        });
        switchArray[switcher].clear();
        switcher++;
        switcher %= 2;
        N++
    }

    console.log(N)
    console.log("tree", tree);
    tree = null;
    console.log("tree cluster", treeCluster);
    let ray = new BABYLON.Ray(new BABYLON.Vector3(-8, 0, 0), BABYLON.Axis.X, 20);
    BABYLON.RayHelper.CreateAndShow(ray, scene, BABYLON.Color3.White());

    //console.log(box.getVerticesData(BABYLON.VertexBuffer.PositionKind));
    //console.log(box.getIndices().length / 3);

    const t0 = performance.now();

    let hits = [];
    for (var k = 0; k < 10000; k++) {
        hits = bvhRayIntersect(ray, treeCluster, box.getVerticesData(BABYLON.VertexBuffer.PositionKind), box.getIndices());
    }
    const t1 = performance.now();
    console.log(`Call to doSomething took ${t1 - t0} milliseconds.`);

    let mat = new BABYLON.StandardMaterial("", scene);
    mat.diffuseColor = BABYLON.Color3.Red();
    
    let inds = box.getIndices();
    let idx0 = 0;
    let idx1 = 0;
    let idx2 = 0;
    let cntrd = BABYLON.Vector3.Zero();
    for (let i = 0; i < hits.length; i++) {
        let box = BABYLON.MeshBuilder.CreateBox("", {size: 0.05}, scene);
        box.position = ray.origin.add(ray.direction.normalize().scale(hits[i].distance))
        box.material = mat;

    }
    console.log("TC", treeCluster);
    console.log("TC", treeCluster);
});

	return scene;

};




var scene = createScene();

engine.runRenderLoop(function () {
  scene.render();

});

window.addEventListener("resize", function () {
    engine.resize();
});
        }
    </script>
</body>
</html>
